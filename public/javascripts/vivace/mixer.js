// Generated by CoffeeScript 1.4.0
(function() {
  var RoutingMethods, gui, mixer, _createSliders, _makeAudioNodes, _mixerDef, _route;

  _mixerDef = function() {
    this.pan = 0;
    return this.gain = Math.sqrt(2) / 2;
  };

  RoutingMethods = {
    _mixerDef: 'src=>gain=>pan=>destination',
    apply: function(tree, mixer, def) {
      var array;
      array = def.split('=>');
      if (array) {
        _makeAudioNodes(tree, mixer);
        return _route(tree, array);
      } else {
        throw new Error('string is not a valid route method');
      }
    }
  };

  _makeAudioNodes = function(nodestree, mixer) {
    return $.each(mixer, function(k, param) {
      if (k === 'gain') {
        nodestree[k] = window.Vivace.audiocontext.createGain();
        return nodestree[k].gain.value = param;
      } else if (k === 'pan') {
        nodestree[k] = window.Vivace.audiocontext.createPanner("equalpower", "exponential");
        return nodestree[k].setPosition(0, 0, 0);
      }
    });
  };

  _route = function(nodestree, array) {
    return $.each(array, function(i, current) {
      var indexCurrent, indexNext, nodeA, nodeB;
      indexCurrent = array.indexOf(current);
      indexNext = array.indexOf(array[i + 1]);
      if (indexCurrent > -1 && indexNext > -1 && indexNext > indexCurrent) {
        nodeA = array[indexCurrent];
        nodeB = array[indexNext];
        if (nodeB !== 'destination') {
          if (nodestree[nodeB] !== void 0 && nodestree[nodeA] !== void 0) {
            nodestree[nodeA].connect(nodestree[nodeB]);
          }
        }
        if (nodeB === 'destination') {
          if (nodestree[nodeA] !== void 0) {
            nodestree[nodeA].connect(Vivace.audiocontext.destination);
          }
        }
        return console.log('connecting ' + nodeA + ' -> ' + nodeB);
      }
    });
  };

  _createSliders = function(folder, mix, voicename, option, value) {
    var control;
    control = null;
    if (option !== 'buffer') {
      if (option === 'pan' || option === 'gain') {
        control = folder.add(mix, option, value.min, value.max);
        return control.onChange = value.onChange;
      }
    }
  };

  gui = new dat.GUI();

  mixer = {
    router: function(voicename, buffer, mxDef, routingMethod) {
      var source, voice, _mix;
      if (mxDef == null) {
        mxDef = _mixerDef;
      }
      if (routingMethod == null) {
        routingMethod = RoutingMethods._mixerDef;
      }
      voice = Vivace.voices[voicename];
      source = voice.audionodes.src = Vivace.audiocontext.createBufferSource();
      voice.audionodes.src.buffer = buffer;
      _mix = new mxDef();
      try {
        RoutingMethods.apply(voice.audionodes, _mix, routingMethod);
        return {
          'mixer': _mix,
          'chain': voice.audionodes
        };
      } catch (e) {
        return console.log(e);
      }
    },
    createChannel: function(voicename, options, createSliderCallback) {
      var folder, routing;
      if (createSliderCallback == null) {
        createSliderCallback = _createSliders;
      }
      routing = Vivace.mixer.router(voicename, options.buffer);
      folder = gui.addFolder(voicename);
      return $.each(options, function(option, value) {
        return createSliderCallback(folder, routing.mixer, voicename, option, value);
      });
    }
  };

  window.Vivace.mixer = mixer;

}).call(this);
