//where are our audio files?
(function(){

	var audioFilesDir = './media/',

//	store all the voices (main symbol table)
	voices = {},

	_events = /init exec loadAudioNodes loadAudioFile loadVideoFile playVoice playVideo tick/g,

	/**
	 * Upside from vivace.js
	 * Construct:
	 * 
	 * new _Vivace(new webkitAudioContext(), {
	 * 	init:
	 *  exec:
	 *  loadAudioNodes:
	 *  loadAudioFile:
	 *  loadVideoFile:
	 *  playVoice:
	 *  playVideo:
	 *  tick:
	 * })
	 */
	_Vivace = function(context, opts){
		this.events = {};

		var i=0;
		$.each(opts, function(k, v){
			if(_events.test(k))
				this.events[k] = v;
			i+=1;
		});

		this.options = opts;
		this.beats = 0;
		this.bpm = 120; // 120 seminimas per minute
		this.minimalUnity = bpm * 4; // we tick at each 960 seminimas (or, 1 semifusa) 
//		change 8:semifusa 4:fusa 2:colcheia 1:seminima as the minor unity
		this.timeInterval = 60 / minimalUnity * 1000; // so, at each 62.5 ms we tick 
		this.semiBreve = 32; // one semibreve is equal to 64 semifusas (hemidemisemiquaver) (or 32 fusas)
//		change 64:semifusa 32:fusa 16:colcheia 8:seminima
		this.masterClock = setInterval(tick, timeInterval);

		//The Vivace GUI definition with jqueryUI
		$.widget('custom.vivace', {
			//TODO
			options:{},
			_create:function(){
				create = "video input menu video"
			},
			_destroy:function(){},
			_setOptions:function(key, val){},
			_setOption:function(key, val){}
			
		});
	};

	_Vivace.utils = {

			availableMethods: /sig amp pos gdur/g,

			//Inspired on Mix.js
			// Utility function for binding events
			on: function( type, callback ){
				_Vivace.events[type] = _Vivace.events[type] || [];
				_Vivace.events[type].push( callback );
			},

			//~~~~~~~~~~~~~~~~~~~~~~~~~
			// Utility function for removing all events of a given type
			off: function( type ){
				_Vivace.events[type] = [];
			},

			//~~~~~~~~~~~~~~~~~~~~~~~~~
			// Utility function for trigger events
			trigger: function( type ){
				if ( !this.events[type] ) return;
				var args = Array.prototype.slice.call(arguments, 1);
				for (var i = 0, l = _Vivace.events[type].length; i < l;  i++)
					if ( typeof _Vivace.events[type][i] == 'function' ) 
						_Vivace.events[type][i].apply(this, args);
			},

			getCodeDefinitions: function(input, callback){
				var tree = vivace.parse(input);
				defs = tree.code.definitions;
				return defs;
			}, 

			defineListValues: function(def, callback){
				var _temp = $.map(def, function(i, e){
					callback(def[i].val);
					return def[i].val;
				});
				//amp.push here

				return _temp;
			},
		
			loadCodeDefinitions: function(codeDef){
				$.each(codeDef, function(i, f){
					// create a dict to each voice
					voices[f.name] = {
						sig: f.fileName, 
						sigType: f.type
					};
					if (f.type === 'audio') {
						loadAudioFile(f.name);

					} else if (f === 'video') {
						loadVideoFile(f.name);
					}
					initfizzy(f);
					init_extra_audionodes(f);
				});
			}
	};

	
	
	_Vivace.prototype.onInit = function(code){
		var _methods = "createTextArea initCodeDefinitions initVideoTag initMenu initGUIMixer"
		_Vivace.utils.on('init', function(){
			createTextArea(code);
			_Vivace.utils.getCodeDefinition('')
		})
	};
	
	_Vivace.prototype.createTextArea = function(code){
		var defCode = "\/\/\/This is a defaultcode generated by Vivace"+applicationVersion+" \n Type ctrl+enter to run\n a.pos = [1, 2, 3] a.gdur = {.1, .2, .3}"
		$('body').append($('<textarea/>').html(code || defCode))
	};
	
	/*
	 * var files = [
	 *	             {name: 'a', fileName: 'kick.wav', type: 'audio'},
	 *	             {name: 'b', fileName: 'dj.wav', type: 'audio'},
	 *             {name: 'c', fileName: 'snare.wav', type: 'audio'},
	 *             {name: 'd', fileName: 'hihat.wav', type: 'audio'},
	 *             {name: 'i', fileName: 'illuminatti.mp4', type: 'video'}];
	 */
	_Vivace.prototype.getCodeDefinition = function(){
		var files = arguments || [];
		for (file in files) {

		}
	};

	_Vivace.prototype.initMenu = function(){
		setupVivaceMenu('div#banner', {
			team:[
			      {name: 'aut0mata', href:'https://github.com/automata'},
			      {name: 'gabiThume', href: 'https://github.com/GabiThume'},
			      {name: 'jahpd', href: 'https://github.com/jahpd'}, 
			      {name: 'hybrid', href: 'http://github.com/'}
			      ],
			      about:[
			             {name: 'src', href: 'https://github.com/automata/vivace'}
			             ],
			             help:[
			                   {name: 'using vivace'},
			                   {name: 'enabled variables'}
			                   ],
			                   ui:[
			                       {name: 'using vivace ui for mixing'}
			                       ]
		});
	};

	_Vivace.prototype.initGUIMixer = function(){
		var gui = new dat.GUI();

		$.each(files, function(i, file){
			var gui = gui.addFolder(file.name);
			var l = gui.add(file.fizzy, 'l', 0, 1);
			var r = gui.add(file.fizzy, 'r', 0, 1);
			gui.add(file.fizzy, 'eq');
			gui.add(file.fizzy, 'high', 0, 1);
			gui.add(file.fizzy, 'medium', 0, 1);
			gui.add(file.fizzy, 'low', 0, 1);
			gui.add(file.fizzy, 'reverb');
			gui.add(file.fizzy, 'reverbTime', 0.1, 3);

			/*
		l.onChange(function(value){
			console.log('file '+file.name+': '+file.audioNode);
		});
		r.onChange(function(value){
			console.log(value);
		});
			 */

		});
	}; 

	_Vivace.prototype.loadAudioNodes = function(file){
		this.ref= getAudionodeByVoicename(file.name);
	};

	_Vivace.loadAudioFile = function(voiceName) {
		var request = new XMLHttpRequest();
		var url = audioFilesDir + voices[voiceName].sig;
		request.open('GET', url, true);
		request.responseType = 'arraybuffer';

		request.onload = function() {
			context.decodeAudioData(request.response, function(buffer) {
				voices[voiceName].buffer = buffer;
			});
		}

		request.onerror = function() {
			console.log('error while loading audio file from ' + url);
		}

		request.send();
	};
	
	Vivace.prototype.exec = function (input) {
		// go to all definitions again and update voices details
		var voiceNames=[];

		$.each(_Vivace.getCodeDefinitions(input), function(i, definition){
			var voiceName = definition.name.val;
			var valid = _Vivace.utils.availableMethods.test(definition.attr.val);

			if(valid){
				switch(definition.attr.val){
				case 'sig':
					if (definition.is.type === 'chains') {
						// for now, just dealing with audio('id') and video('id')
						if (definition.is.val[0].name.val === 'audio') {
							voices[voiceName].sig = definition.is.val[0].parameters[0].val;
							voices[voiceName].sigType = 'audio';
						} else if (definition.is.val[0].name.val === 'video') {
							voices[voiceName].sig = definition.is.val[0].parameters[0].val;
							voices[voiceName].sigType = 'video';
						}
					}
					break;
				case 'amp':
					if (definition.is.type === 'values' || definition.is.type === 'durations') {
						_Vivace.utils.defineListValues(definition.is.val, function(val){
							voices[voiceName].amp = val.reverse();
						});
					}
					break;
				case 'pos':
					if (definition.is.type === 'values' || definition.is.type === 'durations') {
						_Vivace.utils.defineListValues(definition.is.val, function(val){
							voices[voiceName].pos = val.reverse();
						});
					}
					break;
				case 'gdur':
					if (definitions[i].is.type === 'values') {
						_Vivace.utils.defineListValues(definition.is.val, function(val){
							voices[voiceName].gdur = val.reverse();
						});
					} else if (definitions[i].is.type === 'durations') {
						_Vivace.utils.defineListValues(definition.is.val, function(val){
							voices[voiceName].dur = val.reverse();
						});
					}
				}
			}
			else{
				throw Error("input not allowed:"+voiceName);
			}
		});
		return [voices,voiceNames];
	};
	
	_Vivace.prototype.run = function () {
		var code = $('#code').html();

		if(code === undefined || code === null || code.value === ""){
			$('<p/>').appendTo($('body')).html('You didn\'t put code in vivace. Please set').hide('slow');
		}
		else{
			apply(code);
		}
		
		_Vivace.utils.on('exec', function(c){
			console.log('code to be parsed: '+c.value);
			var texec= exec(c.value);
			console.log('javascript: '+texec);
			var currentVoices = texec[0];
			var activeVoices = texec[1];
			
			for (voiceName in lastVoices){
				if (!activeVoices[voiceName]){
					for (e in events) {
						if(events[e]['voiceName']==voiceName) {
							delete events[e];
							voices[voiceName].dur=undefined;
							voices[voiceName].durId=0;
							if (voices[voiceName].sigType=="video"){
								document.getElementById(voiceName).style.zIndex="0";
								voices[voiceName].sigPop.pause();
							}
						}
					}
				}
			}

			for (voiceName in currentVoices) {
				if (lastVoices != null) {
					// let's update durations
					console.log(voiceName, currentVoices, lastVoices);
					if (currentVoices[voiceName].dur != lastVoices[voiceName].dur) {
						console.log(voiceName + "dd");
						if (activeVoices[voiceName]){
							console.log(voiceName + "ee");
							voices[voiceName].dur = currentVoices[voiceName].dur;
						}
					}
					// let's update buffer positions
					if (currentVoices[voiceName].pos != lastVoices[voiceName].pos) {
						voices[voiceName].pos = currentVoices[voiceName].pos;
					}
					// let's update grain durations
					if (currentVoices[voiceName].gdur != lastVoices[voiceName].gdur) {
						voices[voiceName].gdur = currentVoices[voiceName].gdur;
					}      
					console.log(voices[voiceName].dur);
					if (!voices[voiceName].durId && (voices[voiceName].dur!=undefined)) {
						// for every updated voice, put that on event queue
						events.push({'voiceName': voiceName, 'nextBeat': (voices[voiceName].dur[0] * semiBreve) + beats});
						voices[voiceName].durId = 0;
						voices[voiceName].posId = 0;
						voices[voiceName].gdurId = 0;
					}

				} else {
					// so it is the first time we are executing...
					if (!currentVoices[voiceName].dur) {
						voices[voiceName].dur = currentVoices[voiceName].dur;
					}
					if (!currentVoices[voiceName].pos) {
						voices[voiceName].pos = currentVoices[voiceName].pos;
					}
					if (!currentVoices[voiceName].dur) {
						voices[voiceName].gdur = currentVoices[voiceName].gdur;
					}

					if (voices[voiceName].dur) {
						// for every updated voice, put that on event queue
						events.push({'voiceName': voiceName, 'nextBeat': (voices[voiceName].dur[0] * semiBreve) + beats});
						voices[voiceName].durId = 0;
						voices[voiceName].posId = 0;
						voices[voiceName].gdurId = 0;
					}
				}
			}

			// store the last voice to compare at the next one
			lastVoices = voices;
		});

	};

	var getAudionodeByVoicename = function(voiceName){
		return voices[voiceName].buffer;
	};

	var loadVideoFile= function(voiceName) {
		vid = document.createElement('video');
		vid.src = audioFilesDir + voices[voiceName].sig;
		vid.id = voiceName;
		//vid.setAttribute('controls', true);
		//vid.setAttribute('autoplay',true);
		document.getElementsByTagName('body')[0].appendChild(vid);
		voices[voiceName].sigPop = Popcorn('#'+voiceName);
		voices[voiceName].sigPop.preload('auto');
	};

	var playVoice = function(voiceName, when, offset, duration) {
		var source = context.createBufferSource();
		source.buffer = voices[voiceName].buffer;

		source.connect(context.destination);

		// // TODO: here we will use the voices[voiceName].sig dsp graph!!!
		// var gain = context.createGainNode();
		// source.connect(gain);

		// var filter = context.createBiquadFilter();
		// gain.connect(filter);

		// filter.connect(context.destination);
		// gain.gain.value = 0.2;
		// filter.type = 0;
		// filter.frequency.value = 880;

		//source.noteOn(when || context.currentTime);
		source.noteGrainOn(when || context.currentTime, // at specified time or now
				offset || 0, // starting at offset or from start
				duration || source.buffer.duration); // during duration or the whole buffer
	};

	var playVideo = function(voiceName, offset) {
		voices[voiceName].sigPop.play(offset);
	};

	var tick = function() {
		beats += 1;

		$.each(events, function(i, event){
			if (event.nextBeat == beats) {
				var voiceName = event.voiceName;
				if (voices[voiceName].sigType === 'audio') {
					playVoice(voiceName, // voiceName
							context.currentTime, // when
							voices[voiceName].pos[voices[voiceName].posId % voices[voiceName].pos.length], // offset
							voices[voiceName].gdur[voices[voiceName].gdurId % voices[voiceName].gdur.length] // grain duration
					);
					// update event
					voices[voiceName].durId += 1;
					voices[voiceName].posId += 1;
					voices[voiceName].gdurId += 1;

					events[event].nextBeat = (voices[voiceName].dur[voices[voiceName].durId % voices[voiceName].dur.length] * semiBreve) + beats;
				} else if (voices[voiceName].sigType === 'video') {
					playVideo(voiceName, voices[voiceName].pos[voices[voiceName].posId % voices[voiceName].pos.length]);
					voices[voiceName].durId += 1;
					voices[voiceName].posId += 1;
					events[event].nextBeat = (voices[voiceName].dur[voices[voiceName].durId % voices[voiceName].dur.length] * semiBreve) + beats;
					document.getElementById(voiceName).style.zIndex="900";
				}
			}
		})
		/*
		for (event in events) {
			if (events[event].nextBeat == beats) {
				var voiceName = events[event].voiceName;
				if (voices[voiceName].sigType === 'audio') {
					playVoice(voiceName, // voiceName
							context.currentTime, // when
							voices[voiceName].pos[voices[voiceName].posId % voices[voiceName].pos.length], // offset
							voices[voiceName].gdur[voices[voiceName].gdurId % voices[voiceName].gdur.length] // grain duration
					);
					// update event
					voices[voiceName].durId += 1;
					voices[voiceName].posId += 1;
					voices[voiceName].gdurId += 1;

					events[event].nextBeat = (voices[voiceName].dur[voices[voiceName].durId % voices[voiceName].dur.length] * semiBreve) + beats;
				} else if (voices[voiceName].sigType === 'video') {
					playVideo(voiceName, voices[voiceName].pos[voices[voiceName].posId % voices[voiceName].pos.length]);
					voices[voiceName].durId += 1;
					voices[voiceName].posId += 1;
					events[event].nextBeat = (voices[voiceName].dur[voices[voiceName].durId % voices[voiceName].dur.length] * semiBreve) + beats;
					document.getElementById(voiceName).style.zIndex="900";
				}
			}
		}
		 */
	}

//	init ///////////////////////////////

	var fizzyText = function(opt){
		//You will create some filter and effect nodes
		var available = /L R high medium low delayTicks delayTime/g;
		if(opt){
			if(opt.hasOwnProperty('pan')){
				this.pan = false;
				this.pan_opt= $.map(opt.pan, function(k, v){return v});
			}
			if(opt.hasOwnProperty('eq')){
				this.delay = false;
				this.delay_opt = $.map(opt.eq, function(k, v){return v});
			}
			if(opt.hasOwnProperty('delay')){
				this.delay = false;
				this.delay_opt = $.map(opt.delay, function(k, v){return v});
			}	
		}
		//Return default
		else{
			return fizzyText({
				pan:'L R,'
				eq:'high medium low'
			});
		}
	};
	
	var fizzytfy = function(variable, opt){
		//Initialize Audio to setup easyaudiomix
		variable['fizzy'] = new fizzyText(opt);
	};


	/*
	 * <pre>
	 * var  file =  [{name: 'a', fileName: 'kick.wav', type: 'audio'}],
	 * initDat_AudioAPI(file, {
	 * 	pan:function(context){
	 * 		return context.createPanner()
	 *  },
	 *  eq:function(context){
	 *  	return context.createBiquadFilter();
	 *  }
	 * })
	 */
	_Vivace.prototype.initDat_AudioAPI= function(file, opts){
		var dat = file['dat'] = {};
		var options = opts.split(" ");
		var _methods = /pan high medium low ticks time/g;
		var nodes = $.map(file.fizzy, function(i, nodename){
			if(_methods.test(nodename)){
				$.each(options, function(k, v){
					dat[k]=v(this.audioContext);
				});
			}
			else{
				throw new Error("invalid dat audio node:"+nodename);
			}	
		})
	};

	var lastVoices = null;

//	TODO FOUND thred about problem in MacOSX
	var isCtrl = false;
	var onkeyup=function(e){
		if(e.which == 91) 
			isCtrl=false;
	};

	document.onkeydown=function(e){
		//MACOSX version (Snow Leopard)
		//what's the code for cmd+x (run) and cmd+.(stop) [like supercollider and PD]
		var isCmd = false;
		if(e.which == 91) 
			isCmd=true;

		if(e.which == 88 && isCmd) { //x
			console.log('cmd+x pressed, running new vivace code:');
			run();
			return false;
		}
	};

	function setupVivaceMenu(css, o){

		var c = function(){
			var menuVisible = $(this).children().is(':visible');
			if(!menuVisible){
				$(this).children().show('200');
			}
			else{
				$(this).children().hide('200');
			}
		};

		$vivacemenu = $(css).click(c).addClass('ban');

		$.each(o, function(k, v){
			var $div = $('<ul/>').html(k).addClass('ban').click(c);

			$.each(v, function(i, e){
				var href = e['href'] || '#'
				var $a = $('<a/>').html(e['name']).attr('href', href)
				$('<li/>').append($a).appendTo($div);
			})
			$div.appendTo($vivacemenu).hide();
		});    
	};


	function setupVivaceEasyMix(files){
		
	}
}());